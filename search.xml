<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL_2</title>
    <url>/2020/03/09/SQL-2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQL (一) · 基础学习</title>
    <url>/2020/03/08/SQL_1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在我们的日常工作中，使用的是类似 MySQL、Oracle 这种的数据库管理系统，实际上这些数据库管理系统都遵循 SQL 语言，这就意味着，我们在使用这些数据库的时候，都是通过 SQL 语言与它们打交道。所以对于从事编程或者互联网行业的人来说，最具有中台能力的语言便是 SQL 语言。自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p>
<h3 id="SQL-语言按照功能划分成以下的-4-个部分："><a href="#SQL-语言按照功能划分成以下的-4-个部分：" class="headerlink" title="SQL 语言按照功能划分成以下的 4 个部分："></a>SQL 语言按照功能划分成以下的 4 个部分：</h3><ul>
<li><p>DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</p>
</li>
<li><p>DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</p>
</li>
<li><p>DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</p>
</li>
<li><p>DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</p>
<h2 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h2><h3 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h3><ul>
<li>表名、表别名、字段名、字段别名等都小写；</li>
<li>SQL 保留字、函数名、绑定变量等都大写;</li>
<li>此外在数据表的字段名推荐采用下划线命名。</li>
</ul>
<h3 id="DB、DBS-和-DBMS-的区别是什么"><a href="#DB、DBS-和-DBMS-的区别是什么" class="headerlink" title="DB、DBS 和 DBMS 的区别是什么"></a>DB、DBS 和 DBMS 的区别是什么</h3><p>说到 DBMS，有一些概念你需要了解。</p>
</li>
<li><p>DBMS 的英文全称是 DataBase Management System，数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS = 多个数据库（DB） + 管理程序。</p>
</li>
<li><p>DB 的英文是 DataBase，也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。</p>
</li>
<li><p>DBS 的英文是 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。</p>
</li>
</ul>
<img src="/2020/03/08/SQL_1/DBMS.png" class title="DBMS">


<h3 id="MySQL-中的-SQL-是如何执行的"><a href="#MySQL-中的-SQL-是如何执行的" class="headerlink" title="MySQL 中的 SQL 是如何执行的"></a>MySQL 中的 SQL 是如何执行的</h3><p> 首先 MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：</p>
<img src="/2020/03/08/SQL_1/MySQL.png" class title="MySQL">


<p> <strong>MySQL 由三层组成：</strong></p>
<ul>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层：对 SQL 语句进行查询处理；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ul>
<p> <strong>SQL层的结构：</strong></p>
<ul>
<li>查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li>解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li>优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li>执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ul>
<p> <strong>SQL 语句在 MySQL 中的流程是：</strong></p>
<p> SQL 语句→缓存查询→解析器→优化器→执行器</p>
<p>MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ul>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ul>
<p> 数据库的设计在于表的设计，而在 MySQL 中每个表的设计都可以采用不同的存储引擎，我们可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。</p>
<p>WHERE 子句中同时出现 AND 和 OR 操作符的时候，需要考虑到执行的先后顺序，也就是两个操作符执行的优先级。一般来说 () 优先级最高，其次优先级是 AND，然后是 OR。</p>
<img src="/2020/03/08/SQL_1/WHERE.png" class title="WHERE">


<h2 id="常见SQL函数"><a href="#常见SQL函数" class="headerlink" title="常见SQL函数"></a>常见SQL函数</h2><ol>
<li>算术函数<ul>
<li>ABS() 绝对值</li>
<li>MOD() 取余</li>
<li>ROUND() 四舍五入</li>
</ul>
</li>
<li>字符串函数<ul>
<li>CONCAT() 拼接</li>
<li>LENGTH() 字段长度 汉字算三个 数字字母为一</li>
<li>CHAR_LENGTH() 字段长度 汉字数字字母都为一个</li>
<li>LOWER() 转小写</li>
<li>UPPER() 转大写</li>
<li>REPLACE() 替换</li>
<li>SUBSTRING() 截取</li>
</ul>
</li>
<li>日期函数<ul>
<li>CURRENT_DATE() 当前日期</li>
<li>CURRENT_TIME() 当前时间无日期</li>
<li>CURRENT_TIMESTAMP() 日期加时间</li>
<li>EXTRACT() 抽取年月日</li>
<li>DATE() YEAR() MONTH() DAY() HOUR() MINUTE() SECOND() 时间的各个部分 </li>
</ul>
</li>
<li>转换函数<ul>
<li>CAST() 数据类型转换</li>
<li>COALESCE 返回第一个非空值</li>
</ul>
</li>
<li>聚集函数<ul>
<li>COUNT() 总行数</li>
<li>MAX() MIN() 最大最小值</li>
<li>SUM() 求和</li>
<li>AVG() 平均值</li>
<li>DISTINCT() 取唯一</li>
</ul>
</li>
</ol>
<p>在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，可能会遇到不同的大小写问题。</p>
<p>比如 MySQL 在 Linux 的环境下，数据库名、表名、变量名是严格区分大小写的，而字段名是忽略大小写的。</p>
<p>而 MySQL 在 Windows 的环境下全部不区分大小写。</p>
<img src="/2020/03/08/SQL_1/SQL.png" class title="SQL">

<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>对于分组的筛选，我们一定要用 HAVING，而不是 WHERE。另外，HAVING 支持所有 WHERE 的操作，因此所有需要 WHERE 子句实现的功能，都可以使用 HAVING 对分组进行筛选。</p>
<p>用 WHERE 进行数据量的过滤，用 GROUP BY 进行分组，用 HAVING 进行分组过滤，用 ORDER BY 进行排序。</p>
<p> <strong>要记住，在 SELECT 查询中，关键字的顺序是不能颠倒的，它们的顺序是：</strong></p>
<pre><code>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></pre><h2 id="关联子查询，非关联子查询"><a href="#关联子查询，非关联子查询" class="headerlink" title="关联子查询，非关联子查询"></a>关联子查询，非关联子查询</h2><p>子查询虽然是一种嵌套查询的形式，不过我们依然可以依据子查询是否执行多次，从而将子查询划分为关联子查询和非关联子查询。</p>
<ul>
<li><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做非关联子查询。</p>
</li>
<li><p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为关联子查询。</p>
</li>
</ul>
<p> <strong>IN 和 EXIST</strong></p>
<pre><code>SELECT * FROM A WHERE cc IN (SELECT cc FROM B)

SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)</code></pre><p>如果表 A 比表 B 大，那么 IN 子查询的效率要比 EXIST 子查询效率高，因为这时 B 表中如果对 cc 列进行了索引，那么 IN 子查询的效率就会比较高。</p>
<p>同样，如果表 A 比表 B 小，那么使用 EXISTS 子查询效率会更高，因为我们可以使用到 A 表中对 cc 列的索引，而不用从 B 中进行 cc 列的查询。</p>
<p> <strong>ANY、ALL 关键字必须与一个比较操作符一起使用</strong></p>
<p> SQL 中，子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
 <img src="/2020/03/08/SQL_1/%E5%AD%90%E6%9F%A5%E8%AF%A2.png" class title="子查询">

<h2 id="SQL标准"><a href="#SQL标准" class="headerlink" title="SQL标准"></a>SQL标准</h2><p>  SQL 的英文全称叫做 Structured Query Language，它有一个很强大的功能，就是能在各个数据表之间进行连接查询（Query）。这是因为 SQL 是建立在关系型数据库基础上的一种语言。关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。你可以把关系模型理解成一个二维表格模型，这个二维表格是由行（row）和列（column）组成的。每一个行（row）就是一条数据，每一列（column）就是数据在某一维度的属性。</p>
<p>  正是因为在数据库中，表的组成是基于关系模型的，所以一个表就是一个关系。一个数据库中可以包括多个表，也就是存在多种数据之间的关系。而我们之所以能使用 SQL 语言对各个数据表进行复杂查询，核心就在于连接，它可以用一条 SELECT 语句在多张表之间进行查询。你也可以理解为，关系型数据库的核心之一就是连接。</p>
<p>  <strong>SQL 有两个主要的标准，分别是 SQL92 和 SQL99</strong></p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>  笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。</p>
<p>  笛卡尔积也称为交叉连接，英文是 CROSS JOIN，它的作用就是可以把任意表进行连接，即使这两张表不相关。但我们通常进行连接还是需要筛选的，因此你需要在连接后面加上 WHERE 子句，也就是作为过滤条件对连接数据进行筛选。比如后面要讲到的等值连接。</p>
<h3 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h3><p>  两张表的等值连接就是用两张表中都存在的列进行连接。我们也可以对多张表进行等值连接。</p>
<h3 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h3><p>  当我们进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符连接就是非等值查询。</p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>  除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。两张表的外连接，会有一张是主表，另一张是从表。如果是多张表的外连接，那么第一张表是主表，即显示全部的行，而第剩下的表则显示对应连接的信息。在 SQL92 中采用（+）代表从表所在的位置，而且在 SQL92 中，只有左外连接和右外连接，没有全外连接。</p>
<p>  <strong>左右外连接</strong></p>
<p>  就是指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表。</p>
<pre><code>SQL：SELECT * FROM player, team where player.team_id = team.team_id(+)</code></pre><p>  相当于 SQL99 中的：</p>
<pre><code>SQL：SELECT * FROM player LEFT JOIN team on player.team_id = team.team_id</code></pre><p>  右外连接同理</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>  自连接可以对多个表进行操作，也可以对同一个表进行操作。也就是说查询条件使用了当前表的字段。</p>
  <img src="/2020/03/08/SQL_1/SQL%E6%A0%87%E5%87%86.png" class title="SQL标准">

<h2 id="SQL99与SQL92在连接上的区别"><a href="#SQL99与SQL92在连接上的区别" class="headerlink" title="SQL99与SQL92在连接上的区别"></a>SQL99与SQL92在连接上的区别</h2><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>  交叉连接实际上就是 SQL92 中的笛卡尔乘积，只是这里我们采用的是 CROSS JOIN。</p>
<pre><code>SQL: SELECT * FROM player CROSS JOIN team</code></pre><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>  可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。</p>
<p>  SQL92：<br>    SELECT player_id, a.team_id, player_name, height, team_name FROM player as a, team as b WHERE a.team_id = b.team_id</p>
<p>  SQL99：<br>    SELECT player_id, team_id, player_name, height, team_name FROM player NATURAL JOIN team </p>
<h3 id="ON-连接"><a href="#ON-连接" class="headerlink" title="ON 连接"></a>ON 连接</h3><p>  ON 连接用来指定我们想要的连接条件，针对上面的例子，它同样可以帮助我们实现自然连接的功能：</p>
<pre><code>SELECT player_id, player.team_id, player_name, height, team_name FROM player JOIN team ON player.team_id = team.team_id</code></pre><p>  相当于是用 ON 进行了 team_id 字段的等值连接。</p>
<p>  一般来说在 SQL99 中，我们需要连接的表会采用 JOIN 进行连接，ON 指定了连接条件，后面可以是等值连接，也可以采用非等值连接。</p>
<h3 id="USING-连接"><a href="#USING-连接" class="headerlink" title="USING 连接"></a>USING 连接</h3><p>  当我们进行连接的时候，可以用 USING 指定数据表里的同名字段进行等值连接。比如：</p>
<pre><code>SELECT player_id, team_id, player_name, height, team_name FROM player JOIN team USING(team_id)</code></pre><p>  与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。</p>
<h3 id="外连接-1"><a href="#外连接-1" class="headerlink" title="外连接"></a>外连接</h3><p>  SQL99 的外连接包括了三种形式：</p>
<ul>
<li><p>左外连接：LEFT JOIN 或 LEFT OUTER JOIN</p>
</li>
<li><p>右外连接：RIGHT JOIN 或 RIGHT OUTER JOIN</p>
</li>
<li><p>全外连接：FULL JOIN 或 FULL OUTER JOIN</p>
<p>全外连接实际上就是左外连接和右外连接的结合。在这三种外连接中，我们一般省略 OUTER 不写。</p>
<p>MySQL 不支持全外连接，否则的话全外连接会返回左表和右表中的所有行。当表之间有匹配的行，会显示内连接的结果。当某行在另一个表中没有匹配时，那么会把另一个表中选择的列显示为空值。</p>
<p>全外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p>
<h3 id="SQL99-和-SQL92-的区别"><a href="#SQL99-和-SQL92-的区别" class="headerlink" title="SQL99 和 SQL92 的区别"></a>SQL99 和 SQL92 的区别</h3><p>在 SQL92 中进行查询时，会把所有需要连接的表都放到 FROM 之后，然后在 WHERE 中写明连接的条件。而 SQL99 在这方面更灵活，它不需要一次性把所有需要连接的表都放到 FROM 之后，而是采用 JOIN 的方式，每次连接一张表，可以多次使用 JOIN 进行连接。</p>
<p>建议多表连接使用 SQL99 标准，因为层次性更强，可读性更强，比如：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line">        <span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<p>  SQL99 采用的这种嵌套结构非常清爽，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。</p>
<p>  最后一点就是，SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 和 JOIN USING。它们在实际中是比较常用的，省略了 ON 后面的等值条件判断，让 SQL 语句更加简洁。</p>
  <img src="/2020/03/08/SQL_1/SQL99.png" class title="SQL99">

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>  视图，也就是虚拟表</p>
  <img src="/2020/03/08/SQL_1/%E5%BA%94%E7%94%A8%E6%9F%A5%E8%AF%A2.jpg" class title="应用查询">

<h3 id="创建视图-CREATE-VIEW"><a href="#创建视图-CREATE-VIEW" class="headerlink" title="创建视图 CREATE VIEW"></a>创建视图 CREATE VIEW</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<p>  实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。其中 view_name 为视图名称，column1、column2 代表列名，condition 代表查询过滤条件。</p>
<h3 id="修改视图-ALTER-VIEW"><a href="#修改视图-ALTER-VIEW" class="headerlink" title="修改视图 ALTER VIEW"></a>修改视图 ALTER VIEW</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<h3 id="删除视图-DROP-VIEW"><a href="#删除视图-DROP-VIEW" class="headerlink" title="删除视图 DROP VIEW"></a>删除视图 DROP VIEW</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>

<h3 id="视图简化SQL操作"><a href="#视图简化SQL操作" class="headerlink" title="视图简化SQL操作"></a>视图简化SQL操作</h3><ul>
<li><p>完成复杂的连接</p>
</li>
<li><p>对数据进行格式化</p>
</li>
<li><p>使用视图计算字段</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li><p>安全性：虚拟表是基于底层数据表的，我们在使用视图时，一般不会轻易通过视图对底层数据进行修改。</p>
</li>
<li><p>简单清晰：视图是对 SQL 查询的封装，它可以将原本复杂的 SQL 查询简化，在编写好查询之后，我们就可以直接重用它而不必要知道基本的查询细节。</p>
</li>
<li><p>临时表是真实存在的数据表，不过它不用于长期存放数据，只为当前连接存在，关闭连接后，临时表就会自动释放。</p>
<img src="/2020/03/08/SQL_1/%E8%A7%86%E5%9B%BE.png" class title="视图">

<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>SQL 的存储过程是 SQL 中另一个重要应用，和视图一样，都是对 SQL 代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。</p>
<p>存储过程的英文是 Stored Procedure。它的思想很简单，就是 SQL 语句的封装。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用 CREATE PROCEDURE 创建一个存储过程，后面是存储过程的名称，以及过程所带的参数，可以包括输入参数和输出参数。最后由 BEGIN 和 END 来定义我们所要执行的语句块。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    需要执行的语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>  删除已经创建的存储过程，使用的是 DROP PROCEDURE。如果要更新存储过程，我们需要使用 ALTER PROCEDURE。</p>
<p>  例子：<br>  累加运算，计算 1+2+…+n 等于多少</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`add_num`</span>(<span class="keyword">IN</span> n <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> i <span class="built_in">INT</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="built_in">INT</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">SET</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">SET</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              <span class="keyword">SET</span> <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;</span><br><span class="line">              <span class="keyword">SET</span> i = i +<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">       <span class="keyword">SELECT</span> <span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>  如果你使用 Navicat 这个工具来管理 MySQL 执行存储过程，那么直接执行上面这段代码就可以了。如果用的是 MySQL，你还需要用 DELIMITER 来临时定义新的结束符。因为默认情况下 SQL 采用（；）作为结束符，这样当存储过程中的每一句 SQL 结束之后，采用（；）作为结束符，就相当于告诉 SQL 可以执行这一句了。但是存储过程是一个整体，我们不希望 SQL 逐条执行，而是采用存储过程整段执行的方式，因此我们就需要临时定义新的 DELIMITER，新的结束符可以用（//）或者（$$）。如果你用的是 MySQL，那么上面这段代码，应该写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`add_num`</span>(<span class="keyword">IN</span> n <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> i <span class="built_in">INT</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="built_in">INT</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">SET</span> i = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">SET</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              <span class="keyword">SET</span> <span class="keyword">sum</span> = <span class="keyword">sum</span> + i;</span><br><span class="line">              <span class="keyword">SET</span> i = i +<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">       <span class="keyword">SELECT</span> <span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="存储过程的三种参数类型"><a href="#存储过程的三种参数类型" class="headerlink" title="存储过程的三种参数类型"></a>存储过程的三种参数类型</h3>  <img src="/2020/03/08/SQL_1/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%B1%BB%E5%9E%8B.png" class title="存储过程类型">

<p>  例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`get_hero_scores`</span>(</span><br><span class="line">       <span class="keyword">OUT</span> max_max_hp <span class="built_in">FLOAT</span>,</span><br><span class="line">       <span class="keyword">OUT</span> min_max_mp <span class="built_in">FLOAT</span>,</span><br><span class="line">       <span class="keyword">OUT</span> avg_max_attack <span class="built_in">FLOAT</span>,  </span><br><span class="line">       s <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">       )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(hp_max), <span class="keyword">MIN</span>(mp_max), <span class="keyword">AVG</span>(attack_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main = s <span class="keyword">INTO</span> max_max_hp, min_max_mp, avg_max_attack;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>  调用存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> get_hero_scores(@max_max_hp, @min_max_mp, @avg_max_attack, <span class="string">'战士'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @max_max_hp, @min_max_mp, @avg_max_attack;</span><br></pre></td></tr></table></figure>

<h3 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h3><ol>
<li>BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</li>
<li>DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</li>
<li>SET：赋值语句，用于对变量进行赋值。</li>
<li>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</li>
<li>IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用 ELSE 和 ELSEIF 来进行条件判断。</li>
<li>CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE </span><br><span class="line">	WHEN expression1 THEN ...</span><br><span class="line">	WHEN expression2 THEN ...</span><br><span class="line">	...</span><br><span class="line">    ELSE </span><br><span class="line">    <span class="comment">--ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE 可以跳出循环，使用 ITERATE 则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 BREAK，把 ITERATE 理解为 CONTINUE。</p>
</li>
<li><p>REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
</li>
<li><p>WHILE…DO…END WHILE：这也是循环语句，和 REPEAT 循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</p>
<h3 id="存储过程的争议"><a href="#存储过程的争议" class="headerlink" title="存储过程的争议"></a>存储过程的争议</h3></li>
</ol>
<ul>
<li><p>优点</p>
<ul>
<li>多次使用</li>
<li>可以封装，减少工作量，代码结构清晰</li>
<li>安全性强</li>
<li>减少网络传输</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>可移植性差</li>
<li>调试困难</li>
<li>版本管理困难</li>
<li>不适合高并发场景</li>
</ul>
<img src="/2020/03/08/SQL_1/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" class title="存储过程">

<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>要么完全执行，要么都不执行。不过要对事务进行更深一步的理解，还要从事务的 4 个特性说起，这 4 个特性用英文字母来表达就是 ACID。</p>
</li>
<li><p>A，也就是原子性（Atomicity）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</p>
</li>
<li><p>C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</p>
</li>
<li><p>I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</p>
</li>
<li><p>D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。</p>
<p>ACID 可以说是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p>
<p>任何写入数据库中的数据都需要满足我们事先定义的约束规则。事务操作会让数据表的状态变成另一种一致的状态，如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<p>事务的另一个特点就是持久性，持久性是通过事务日志来保证的。日志包括了回滚日志和重做日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h3 id="事务的控制"><a href="#事务的控制" class="headerlink" title="事务的控制"></a>事务的控制</h3><p>MySQL，可以通过 SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。InnoDB 是支持事务的，而 MyISAM 存储引擎不支持事务。</p>
</li>
</ul>
<ol>
<li><p>START TRANSACTION 或者 BEGIN，作用是显式开启一个事务。</p>
</li>
<li><p>COMMIT：提交事务。当提交事务后，对数据库的修改是永久性的。</p>
</li>
<li><p>ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。</p>
</li>
<li><p>SAVEPOINT：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</p>
</li>
<li><p>RELEASE SAVEPOINT：删除某个保存点。</p>
</li>
<li><p>SET TRANSACTION，设置事务的隔离级别。</p>
<p>需要说明的是，使用事务有两种方式，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交，当然我们可以配置 MySQL 的参数：</p>
<p>mysql&gt; set autocommit =0;  // 关闭自动提交<br>mysql&gt; set autocommit =1;  // 开启自动提交</p>
<p>MySQL 中 completion_type 参数的作用，实际上这个参数有 3 种可能：</p>
</li>
<li><p>completion=0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION 或者 BEGIN 来开启。</p>
</li>
<li><p>completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务（隔离级别会在下一节中进行介绍）。</p>
</li>
<li><p>completion=2，这种情况下 COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断开连接。</p>
<p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>正是因为有事务的存在，即使在数据库操作失败的情况下，也能保证数据的一致性。同样，多个应用程序访问数据库的时候，事务可以提供隔离，保证事务之间不被干扰。最后，事务一旦提交，结果就会是永久性的，这就意味着，即使系统崩溃了，数据库也可以对数据进行恢复。</p>
<p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<img src="/2020/03/08/SQL_1/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86.png" class title="事务处理">

<h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2></li>
</ol>
]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark(二) · 核心编程</title>
    <url>/2020/02/26/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spark-二-·-核心编程"><a href="#Spark-二-·-核心编程" class="headerlink" title="Spark(二) · 核心编程"></a>Spark(二) · 核心编程</h1>]]></content>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark(一) · 初识</title>
    <url>/2020/02/25/Spark%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Spark-一-·-初识"><a href="#Spark-一-·-初识" class="headerlink" title="Spark(一) · 初识"></a>Spark(一) · 初识</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>需要的环境</p>
<ul>
<li>Linux</li>
<li>Python : 3.6</li>
<li>Hadoop : 5.7以上</li>
<li>Spark : 2.3.0以上</li>
<li>ElasticSearch : 6.3.0</li>
<li>Kibana : 6.3.0</li>
<li>JDK : 1.8</li>
<li>Azkaban : 3.x</li>
</ul>
<p>掌握技巧</p>
<ul>
<li>tar解压命令</li>
<li>环境的配置</li>
</ul>
<h2 id="PySpark-Spark-Core核心RDD"><a href="#PySpark-Spark-Core核心RDD" class="headerlink" title="PySpark-Spark Core核心RDD"></a>PySpark-Spark Core核心RDD</h2><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><h4 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h4><p>源码： <a href="https://github.com/apache/spark" target="_blank" rel="noopener">https://github.com/apache/spark</a></p>
<p>1) RDD是一个抽象类<br>2) 带泛型，可以支持多种类型</p>
<p>RDD: Resilient Distributed Dataset 弹性 分布式 数据集</p>
<p>Represents an<br>immutable 不可变<br>partitioned collection of elements 分区<br>that can be operated on in parallel. 并行计算</p>
<p>单机存储/计算 ==&gt; 分布式存储/计算</p>
<p>1) 数据的存储: 切割    HDFS的Block<br>2) 数据的计算: 切割(分布式并行计算)    MapReduce/Spark<br>3) 存储+计算: HDFS/S3+MapReduce/Spark</p>
<h4 id="RDD的特性"><a href="#RDD的特性" class="headerlink" title="RDD的特性"></a>RDD的特性</h4><p>Internally, each RDD is characterized by five main properties:</p>
<ul>
<li>A list of partitions</li>
<li>系列的分区/分片</li>
<li>A function for computing each split</li>
<li>操作是对每个分区的</li>
<li>A list of dependencies on other RDDs</li>
<li>RDD存在依赖关系(核心,非常重要)</li>
<li>Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</li>
<li>分区策略</li>
<li>Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</li>
<li>数据在哪优先把作业调度到数据所在的节点进行计算</li>
</ul>
<p><strong>五大特性</strong></p>
<ul>
<li>def compute(split: Partition, context: TaskContext): Iterator[T] 特性二</li>
<li>def getPartitions: Array[Partition] 特性一</li>
<li>def getDependencies: Seq[Dependency[_]] = deps 特性三</li>
<li>def getPreferredLocations(split: Partition): Seq[String] = Nil 特性五</li>
<li>val partitioner: Option[Partitioner] = None 特性四</li>
</ul>
<p>有两种方式创建RDD </p>
<ul>
<li><p>把一个集合转成RDD Parallelized Collections</p>
</li>
<li><p>把外部数据集Hadoop的兼容转换成RDD External Datasets</p>
</li>
</ul>
<h3 id="SparkContext-amp-SparkConf"><a href="#SparkContext-amp-SparkConf" class="headerlink" title="SparkContext&amp;SparkConf"></a>SparkContext&amp;SparkConf</h3><p>第一要务:创建SparkContext</p>
<ul>
<li><p>连接到Spark集群:local,standalone,yarn,mesos</p>
</li>
<li><p>通过SparkContext来创建RDD，广播变量到集群</p>
</li>
</ul>
<p>在创建SparkContext之前还需要创建SparkConf(优先级高于系统)</p>
<h3 id="PySpark脚本"><a href="#PySpark脚本" class="headerlink" title="PySpark脚本"></a>PySpark脚本</h3><h3 id="Spark应用程序及开发"><a href="#Spark应用程序及开发" class="headerlink" title="Spark应用程序及开发"></a>Spark应用程序及开发</h3><p>1) IDE: pycharm</p>
<p>2) 设置基本参数: python interceptor  PYTHONPATH SPARK_HOME 2zip包</p>
<p>3) 开发</p>
<p>4) 使用local进行本地测试</p>
<p>提交pyspark应用程序</p>
<pre><code>spark-submit --master local[2] --name sparktest /home/***/*.py</code></pre>]]></content>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Redis</title>
    <url>/2020/02/24/Redis%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件。</p>
<h3 id="我们可以从缓存开始熟悉"><a href="#我们可以从缓存开始熟悉" class="headerlink" title="我们可以从缓存开始熟悉"></a>我们可以从缓存开始熟悉</h3><p>实现一个缓存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get value from cache</span></span><br><span class="line"><span class="keyword">String</span> value = <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">if</span>(null == value) &#123;</span><br><span class="line"> <span class="comment">// get value from DataBase</span></span><br><span class="line"> value = queryValueFromDB(<span class="string">"someKey"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap、TreeMap这些都线程不安全，可以用HashTable或者ConcurrentHashMap。</p>
<p>不管你用什么样的Map，它的背后都是key-value的Hash表结构，目的就是为了实现O(1)复杂度的查找算法，Redis也是这样实现的，另一个常用的缓存框架Memcached也是。</p>
<p>Hash表的数据结构是怎样的呢？<br><img src="https://pic1.zhimg.com/80/v2-84e2b36df3700de8417fa052b3ac19b8_hd.jpg" alt="hash"></p>
<p>简单说，Hash表就是一个数组，而这个数组的元素，是一个链表。</p>
<p>为什么元素是链表？理论上，如果我们的数组可以做成无限大，那么每来一个key，我们都可以把它放到一个新的位置。但是这样很明显不可行，数组越大，占用的内存就越大。</p>
<p>所以我们需要限制数组的大小，假设是16，那么计算出key的hash值后，对16取模，得出一个0~15的数，然后放到数组对应的位置上去。</p>
<p>好，现在key1放到index为2的位置，突然又来了一个key9，刚好他也要放到index为2的位置，那咋办，总不能把人家key1给踢掉吧？所以key1的信息必须存储在一个链表结构里面，这样key9来了之后，只需要把key1所在的链表节点的next，指向key9的链表节点即可。</p>
<p>很明显，链表越长，Hash表的查询、插入、删除等操作的性能都会下降，极端情况下，如果全部元素都放到了一个链表里头，复杂度就会降为O(n)，也就和顺序查找算法无异了。（正因如此，Java8里头的HashMap在元素增长到一定程度时会从链表转成一颗红黑树，来减缓查找性能的下降）</p>
<p>怎么解决？rehash。关于rehash，这里就不细讲了，大家可以先了解一下Java HashMap的resize函数，然后再通过这篇文章：<a href="https://medium.com/@kousiknath/a-little-internal-on-redis-key-value-storage-implementation-fdf96bac7453" target="_blank" rel="noopener">A little internal on redis key value storage implementation</a> 去了解Redis的rehash算法，你会惊讶的发现Redis里头居然是两个HashTable。</p>
<h3 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h3><p>作为Redis用户，我们要怎样把数据放到上面提到的Hash表里呢？</p>
<p>我们可以通过Redis的命令行，当然也可以通过各种语言的Redis API，在代码里面对Hash表进行操作，所以我们可以将Redis看作是一个C/S架构，客户端是各种操作，Hash表是服务端。</p>
<p>显然，Client和Server可以是在一台机器上的，也可以不在：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d67c538b3a759800eb8102b5eeefee01_hd.jpg" alt="client"></p>
<p><a href="http://try.redis.io/" target="_blank" rel="noopener">try redis</a>这个网站可以用来熟悉Reids的操作</p>
<p>值得一提的是，Redis的Server是单线程服务器，基于Event-Loop模式来处理Client的请求，这一点和NodeJS很相似。使用单线程的好处包括：</p>
<ul>
<li><p>不必考虑线程安全问题。很多操作都不必加锁，既简化了开发，又提高了性能；</p>
</li>
<li><p>减少线程切换损耗的时间。线程一多，CPU在线程之间切来切去是非常耗时的，单线程服务器则没有了这个烦恼；</p>
</li>
</ul>
<p>当然，单线程服务器最大的问题自然是无法充分利用多处理器。</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>搭起这样一个框架，一台客户端，一台Redis缓存服务器</p>
<p>随着系统中使用Redis的客户端越来越多，会带来两个问题：</p>
<ul>
<li>Redis内存不足：随着使用Redis的客户端越来越多，Redis上的缓存数据也越来越大，而一台机器的内存毕竟是有限的，放不了那么多数据；</li>
<li>Redis吞吐量低：客户端变多了，可Redis还是只有一台，而且我们已经知道，Redis是单线程的！一台机器的带宽和处理器都是有限的，Redis自然会忙不过来，吞吐量已经不足以支撑我们越来越庞大的系统。</li>
</ul>
<p>可以通过集群的方式解决问题</p>
<p><img src="https://pic1.zhimg.com/80/v2-3ea442fd9cfba7ae0569f40e764dd8f0_hd.jpg" alt="集群"></p>
<p>客户端的请求会通过负载均衡算法（通常是一致性Hash），分散到各个Redis服务器上。</p>
<p>通过集群，我们实现了两个特性：</p>
<ul>
<li>扩大缓存容量；</li>
<li>提升吞吐量；</li>
</ul>
<p>解决了上面提到的两个问题。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>现在我们已经把Redis升级到了集群，真可谓效果杠杠的，可运行了一段时间后，运维又过来反馈了两个问题：</p>
<ul>
<li>数据可用性差：如果其中一台Redis挂了，那么上面全部的缓存数据都会丢失，导致原来可以从缓存中获取的请求，都去访问数据库了，数据库压力陡增。</li>
<li>数据查询缓慢：监测发现，每天有一段时间，Redis 1的访问量非常高，而且大多数请求都是去查一个相同的缓存数据，导致Redis 1非常忙碌，吞吐量不足以支撑这个高的查询负载。</li>
</ul>
<p>问题分析完，要想解决可用性问题，我们第一个想到的，就是数据库里头经常用到的Master-Slave模式，于是，我们给每一台Redis都加上了一台Slave：</p>
<p><img src="https://pic4.zhimg.com/80/v2-b971a5e0d88583cdb8c5c550b5e5b2ab_hd.jpg" alt="slave"></p>
<p>通过Master-Slave模式，我们又实现了两个特性：</p>
<ul>
<li>数据高可用：Master负责接收客户端的写入请求，将数据写到Master后，同步给Slave，实现数据备份。一旦Master挂了，可以将Slave提拔为Master；</li>
<li>提高查询效率：一旦Master发现自己忙不过来了，可以把一些查询请求，转发给Slave去处理，也就是Master负责读写或者只负责写，Slave负责读；</li>
</ul>
<p>为了让Master-Slave模式发挥更大的威力，我们当然可以放更多的Slave，就像这样：</p>
<p><img src="https://pic4.zhimg.com/80/v2-76238e772c8bb5feaa5bb20e4207cfcf_hd.jpg" alt="更多slave"></p>
<p>可这样又引发了另一个问题，那就是Master进行数据备份的工作量变大了，Slava每增加一个，Master就要多备份一次，于是又有了Master/slave chains的架构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-eb813169598035287738730a5f53c2cc_hd.jpg" alt="chains"></p>
<p>这样最顶层的Master的备份压力就没那么大了，它只需要备份两次，然后让那它底下的那两台Slave再去和他们的Slave备份。</p>
<p>事实上，Redis内部要处理的问题还有很多：</p>
<ul>
<li>数据结构。文章一开头提到了，Redis不仅仅是数据存储器，而是数据结构存储器。那是因为Redis支持客户端直接往里面塞各种类型的数据结构，比如String、List、Set、SortedSet、Map等等。你或许会问，这很了不起吗？我自己在Java里写一个HashTable不也可以放各种数据结构？呵呵，要知道你的HashTable只能放Java对象，人家那可是支持多语言的，不管你的客户端是Java还是Python还是别的，都可以往Redis塞数据结构。这一点也是Redis和Memcached相比，非常不同的一点。当然Redis要支持数据结构存储，是以牺牲更多内存为代价的，正所谓有利必有弊。关于Redis里头的数据结构，大家可以参考：<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">Redis Data Types</a></li>
<li>剔除策略。缓存数据总不能无限增长吧，总得剔除掉一些数据，好让新的缓存数据放进来吧？这就需要LRU算法了，大家可以参考：<a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">Redis Lru Cache</a></li>
<li>负载均衡。用到了集群，就免不了需要用到负载均衡，用什么负载均衡算法？在哪里使用负载均衡？这点大家可以参考：<a href="https://redis.io/topics/partitioning" target="_blank" rel="noopener">Redis Partitioning</a></li>
<li>Presharding。如果一开始只有三台Redis服务器，后来发现需要加多一台才能满足业务需要，要怎么办？Redis提供了一种策略，叫：<a href="https://redis.io/topics/partitioning#presharding" target="_blank" rel="noopener">Presharding</a></li>
<li>数据持久化。如果我的机器突然全部断电了，我的缓存数据还能恢复吗？Redis说，相信我，可以的，不然我怎么用作数据库？去看看这个：<a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">Redis Persistence</a>]</li>
<li>数据同步。这篇文章里提到了主从复制，那么Redis是怎么进行主从复制的呢？根据CAP理论，既然我们已经选择了集群，也就是P，分区容忍性，那么剩下那两个，Consistency和Availability只能选择一个了，那么Redis到底是支持最终一致性还是强一致性呢？可以参考：<a href="https://redis.io/topics/replication" target="_blank" rel="noopener">Redis Replication</a></li>
</ul>
<blockquote>
<p>参考知乎<a href="https://zhuanlan.zhihu.com/p/37055648" target="_blank" rel="noopener">Redis简明教程</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
